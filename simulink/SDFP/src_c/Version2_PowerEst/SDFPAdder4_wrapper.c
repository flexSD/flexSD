/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Tue Feb 23 18:06:41 2010
  */

/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void SDFPAdder4_Outputs_wrapper(const uint32_T *in0,
                          const uint32_T *in1,
                          const uint32_T *in2,
                          const uint32_T *in3,
                          uint32_T *adder_out,
                          real_T *pwr_switching_inst,
                          real_T *pwr_leakage_inst,
                          real_T *pwr_total_inst ,
			      const real_T  *xD,
                          const uint32_T  *in_bitwidth, const int_T  p_width0, 
                          const uint32_T  *in_fp_position, const int_T  p_width1, 
                          const uint32_T  *out_bitwidth, const int_T  p_width2, 
                          const uint32_T  *out_fp_position, const int_T  p_width3, 
                          const real_T  *frequency, const int_T  p_width4, 
                          const uint32_T  *input_count, const int_T p_width5)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
/* This sample sets the output equal to the input
         y0[0] = u0[0];
For complex signals use: y0[0].re = u0[0].re;
                         y0[0].im = u0[0].im;
                         y1[0].re = u1[0].re;
                         y1[0].im = u1[0].im;*/

#define TESTdprintf(format, args ...) ;
#define dprintf(format, args...) printf(format, ##args)

   /* Just "rename" the input parameters. */
   uint32_T t_in0 = in0[0];
   uint32_T t_in1 = in1[0];
   uint32_T t_in2 = in2[0];
   uint32_T t_in3 = in3[0];
   uint32_T t_in_bitwidth = in_bitwidth[0];
   uint32_T t_in_fp_position = in_fp_position[0];
   uint32_T t_out_bitwidth = out_bitwidth[0];
   uint32_T t_out_fp_position = out_fp_position[0];
   uint32_T t_adder_out;
   
   int i;

   /* Power Variables */
   uint32_T input_transitions = 0;

   /* Determine which bits have changed since last time */
   uint32_T last_in0 = xD[0];
   uint32_T last_in1 = xD[1];
   uint32_T last_in2 = xD[2];
   uint32_T last_in3 = xD[3];

   uint32_T last_carry0 = 0;
   uint32_T last_carry1 = 0;

   /* Carry bits */
   uint32_T sum0 = 0, carry0 = 0, carry1 = 0;

   /* Calculate the total number of input transitions */
   uint32_T t0 = t_in0, t1 = t_in1, t2 = t_in2, t3 = t_in3; 
   uint32_T l0 = last_in0, l1 = last_in1, l2 = last_in2, l3 = last_in3; 

   for( i = 0; i < t_in_bitwidth; i++ ) { /* Go LSB -> MSB */

      uint32_T last_lsb0=(l0 & 0x1);
      uint32_T last_lsb1=(l1 & 0x1);
      uint32_T last_lsb2=(l2 & 0x1);
      uint32_T last_lsb3=(l3 & 0x1);

      uint32_T lsb0=(t0 & 0x1);
      uint32_T lsb1=(t1 & 0x1);
      uint32_T lsb2=(t2 & 0x1);
      uint32_T lsb3=(t3 & 0x1);

      /* dprintf("last_lsb0=%d lsb0=%d\n", last_lsb0, lsb0); */

      /* If this bit changed: */
      if(last_lsb0 ^ lsb0) input_transitions += 1; 
      if(last_lsb1 ^ lsb1) input_transitions += 1; 
      if(last_lsb2 ^ lsb2) input_transitions += 1; 
      if(last_lsb3 ^ lsb3) input_transitions += 1; 

      /* Calculate Last Inputs' Carries */ 
      uint32_T last_countones = (last_lsb0+last_lsb1+last_lsb2+last_lsb3);
      int last_sumbit = (last_countones) & 0x1;
      int last_carrybit1 = (last_countones>>1) & 0x1;
      int last_carrybit2 = (last_countones>>2) & 0x1;
      last_carry0 = last_carry0 | (last_carrybit1 << i);
      last_carry1 = last_carry1 | (last_carrybit2 << i);
      dprintf("\t\t\t\t\t\t\t\t{lsb0,lsb1,lsb2,lsb3}={%d%d%d%d} {carrybit2,carrybit1,sumbit}=%d%d%d\n", last_lsb0, last_lsb1, last_lsb2, last_lsb3, last_carrybit2, last_carrybit1, last_sumbit);

      /* Calculate Carries from New Inputs */
      uint32_T countones = (lsb0+lsb1+lsb2+lsb3);
      int sumbit = (countones) & 0x1; /* In case we need it */
      int carrybit1 = (countones>>1) & 0x1;
      int carrybit2 = (countones>>2) & 0x1;
      carry0 = carry0 | (carrybit1 << i);
      carry1 = carry1 | (carrybit2 << i);
      dprintf("{lsb0,lsb1,lsb2,lsb3}={%d%d%d%d} {carrybit2,carrybit1,sumbit}=%d%d%d\n", lsb0, lsb1, lsb2, lsb3, carrybit2, carrybit1, sumbit);

      /* If this is not the last bit, calculate the carry outputs (which are input into the next stage, therefore adding
       * to our transition count */
      if( i != t_in_bitwidth-1 ) {
         if(carrybit1 ^ last_carrybit1) input_transitions += 1;
         if(carrybit2 ^ last_carrybit2) input_transitions += 1;
      }

      /* Shift everything over */
      t0 >>= 1; t1 >>= 1; t2 >>= 1; t3 >>= 1;
      l0 >>= 1; l1 >>= 1; l2 >>= 1; l3 >>= 1;
   }

   /* Do sum. */
   uint32_T in0_in1 = t_in0 + t_in1;
   uint32_T in0_in1_in2 = in0_in1 - t_in2;
   t_adder_out = in0_in1_in2 + t_in3;
   /*t_adder_out = t_in0 + t_in1 - t_in2 + t_in3;*/
   dprintf("t_adder_out = %08x\n", t_adder_out );

   /* Make any adjustments if necessary. */
   if( t_out_fp_position != t_in_fp_position ) {
       if( t_out_fp_position < t_in_fp_position ) {
          /* shift right */
          t_adder_out >>= (t_in_fp_position - t_out_fp_position);
          dprintf("shift t_adder_out by %d bits\n", (t_in_fp_position - t_out_fp_position));
       } else if( t_out_fp_position > t_in_fp_position ) {
          /* shift left if we don't have enough bits. */
          t_adder_out <<= (t_out_fp_position - t_in_fp_position);
       }
       dprintf("t_adder_out, adjusted = %08x\n", t_adder_out );
   }
   
   adder_out[0] = t_adder_out;

   double coef_static=0.0f, coef_switching=0.0f;

   if(input_count[0] == 4) {
      coef_static = 5.2e-11;
      coef_switching = 3.42e-15;
   } else if(input_count[0] == 3) {
      coef_static = 4.8e-11;
      coef_switching = 3.08e-15;
   } else if(input_count[0] == 2) {
      coef_static = 1.5e-11;
      coef_switching = 1.01e-15;
   }

   pwr_switching_inst[0] = 0.5f * coef_switching * (input_transitions * frequency[0]);
   pwr_leakage_inst[0] = 0.5f * coef_static;
   pwr_total_inst[0] = pwr_switching_inst[0] + pwr_leakage_inst[0];

   dprintf("input_transitions=%d pwr_switching_inst=%.50f\n", input_transitions, pwr_switching_inst[0]);

/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}

/*
  * Updates function
  *
  */
void SDFPAdder4_Update_wrapper(const uint32_T *in0,
                          const uint32_T *in1,
                          const uint32_T *in2,
                          const uint32_T *in3,
                          const uint32_T *adder_out,
                          const real_T *pwr_switching_inst,
                          const real_T *pwr_leakage_inst ,
                          real_T *xD, 
                          const uint32_T  *in_bitwidth,  const int_T  p_width0,
                          const uint32_T  *in_fp_position,  const int_T  p_width1,
                          const uint32_T  *out_bitwidth,  const int_T  p_width2,
                           const uint32_T *out_fp_position, const int_T  p_width3)
{
  /* %%%-SFUNWIZ_wrapper_Update_Changes_BEGIN --- EDIT HERE TO _END */
xD[0] = in0[0];
xD[1] = in1[0];
xD[2] = in2[0];
xD[3] = in3[0];
/* %%%-SFUNWIZ_wrapper_Update_Changes_END --- EDIT HERE TO _BEGIN */
}
