/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Thu Jan 28 20:06:17 2010
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/* Floating point conversion helper macros */
typedef unsigned int uint32;
#define f32_to_uint32(x) (*((uint32*)(&(x))))
#define f64_to_uint32_lower(x) (*((uint32*)(&(x))))
#define f64_to_uint32_upper(x) (*((uint32*)(&(x))+1))
/**********************************************/
/**  32-bit Floating Point Helper Functions  **/
/**********************************************/
int fp32_get_exponent(float i) {
   uint32 f = f32_to_uint32(i);
   return ((f & 0x7F800000) >> 23) - 127;
} 

uint32 fp32_get_mantissa(float i) {
   uint32 f = f32_to_uint32(i);
   return (f & 0x007FFFFF);
}  
uint32 fp32_get_sign(float i) {
   uint32 f = f32_to_uint32(i);
   return (f & 0x80000000) != 0;
}  

uint32 i32_sweep_bits( int i ) {
   uint32 p = 0, highest = 0;
   while(p < 32) {
      if( i & (1<<p) ) 
         highest = p;
      p++;
   }
   return highest;
}

uint32 fp32_to_fixed_point( float i, int bit_width, int point_position ) {

   assert(bit_width > point_position);

   int      i_exponent = fp32_get_exponent(i);
   uint32   i_mantissa = fp32_get_mantissa(i);
   uint32   i_sign     = fp32_get_sign(i);

#ifndef dprintf
#define dprintf(format, args ...) ;
#endif

   dprintf("i_exponent: %d [%x]\n", i_exponent, i_exponent);
   dprintf("i_mantissa: %d [%x]\n", i_mantissa, i_mantissa);
   dprintf("i_sign: %d\n", i_sign);

   /* Make sure we can even represent the number */
   int i_integer_part = ((uint32)i);
   uint32 integer_msb = i32_sweep_bits(i_integer_part);

   dprintf("integer_msb: %d\n", integer_msb);

   if( integer_msb > (bit_width - point_position) ) {
      fprintf(stderr, "fp32_to_fixed_point: Not enough bits to represent integer portion of number.\n");
      return 0xFFFFFFFF;
   }

   /* Now reduce it to just the fractional part. */
   float f_decimal_part = i - (float)i_integer_part;
   dprintf( "Decimal part, in float form: %e [%x]\n", f_decimal_part, f32_to_uint32(f_decimal_part) );

   int      f_exponent = fp32_get_exponent(f_decimal_part);
   uint32   f_mantissa = fp32_get_mantissa(f_decimal_part);
   uint32   f_sign     = fp32_get_sign(f_decimal_part);

   dprintf("f_exponent: %d [%x]\n", f_exponent, f_exponent);
   dprintf("f_mantissa: %d [%x]\n", f_mantissa, f_mantissa);
   dprintf("f_sign: %d\n", f_sign);

   /* Insert the hidden bit */
   f_mantissa |= 0x00800000;
   /* NOTE: f_mantissa is now the decimal portion in binary, essentially shifted left by 23 digits. */
   dprintf("f_mantissa with hidden bit: %d [%x]\n", f_mantissa, f_mantissa);

   /* Now shift our mantissa to isolate the fractional part */
   uint32 fractional_bits;
   if( f_exponent < 0 ) {
      f_mantissa >>= -f_exponent;
   } else {
      f_mantissa <<= f_exponent;
   }

   dprintf("f_mantissa shifted: %d [%x]\n", f_mantissa, f_mantissa);

   uint32 final_number = 0;
   final_number = (f_mantissa & 0x007FFFFF);
   /* now the lower 23 bits contain the fractional part. We'll truncate it accordingly. */
   if( point_position > 23 ) {
      /* if the fixed point position is more than 23, then shift left to align the most significant
       * fraction part */
      final_number <<= point_position - 23;
   } else if( point_position < 23 ) {
      /* shift right to truncate extra bits */
      final_number >>= 23 - point_position;
   }

   /* Now that the fractional part is in place, we can put the integer portion into place */
   uint32 u_integer_masked = i_integer_part & ((1 << (bit_width-point_position))-1);
   final_number |= u_integer_masked << point_position;

   return final_number;
   
}
/*
 * Output functions
 *
 */
void SDFPGainSwitch_Outputs_wrapper(const real32_T *sd_in,
                          uint32_T *gain_out  , 
                          const real32_T  *gain, const int_T  p_width0, 
                          const uint32_T  *bitwidth, const int_T  p_width1, 
                          const uint32_T  *fp_position,  const int_T p_width2)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
/* This sample sets the output equal to the input
         y0[0] = u0[0];
For complex signals use: y0[0].re = u0[0].re;
                         y0[0].im = u0[0].im;
                         y1[0].re = u1[0].re;
                         y1[0].im = u1[0].im;*/
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
   static uint32_T float_repr;
   static uint32_T converted_float = 0;

   if( converted_float == 0 ) {
      float_repr = f32_to_uint32(gain[0]);
      converted_float = 1;
   }

   if(sd_in[0] == -1) {
      gain_out[0] = -float_repr;
   } else if(sd_in[0] == 1) {
      gain_out[0] = float_repr;
   } else {
      /* Error Case */
      gain_out[0] = 0;
   }
}
